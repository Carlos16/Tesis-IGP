% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}



\title{Tesis Documentation}
\date{March 18, 2015}
\release{1.0}
\author{Carlos M.}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{Introduction:introduction}\label{Introduction::doc}\label{Introduction:welcome-to-tesis-s-documentation}
This file contains all the documentation for the code written for my undergraduate thesis, which explores the relationship that exist between predator body mass and resource-consumer body size ratios over the assembly mechanism of the \emph{intraguild predation} module.
More formally I explore mathematical models of the form :
\begin{gather}
\begin{split}\frac{dR}{dt} &= F(R) - G_c(R)C - G_p(R,C)P \\
\frac{dC}{dt} &= \epsilon_1G_c(R)C - H_p(R,C)P - q_1C \\
\frac{dP}{dt} &= P(\epsilon_2G_p(R,C) + \epsilon_3 H_p(R,C) - q_2)\end{split}\notag
\end{gather}
And find invasibility conditions for each of the subcases assuming point attractors in the \emph{recipient} community.

\emph{More information will come ...}


\chapter{Analisis}
\label{Analisis/modules::doc}\label{Analisis/modules:analisis}

\section{Specifications}
\label{Analisis/modules:specifications}\begin{itemize}
\item {} 
This set of functions and Modules make possible the computation of the invasibility boundaries and the associated zones.

\item {} 
It also has code to explore a range of different parameter combinations and save the results to files.

\end{itemize}


\section{Contents}
\label{Analisis/modules:contents}

\subsection{AuxiliarClases module}
\label{Analisis/AuxiliarClases:module-AuxiliarClases}\label{Analisis/AuxiliarClases::doc}\label{Analisis/AuxiliarClases:auxiliarclases-module}\index{AuxiliarClases (module)}\index{MyFloat (class in AuxiliarClases)}

\begin{fulllineitems}
\phantomsection\label{Analisis/AuxiliarClases:AuxiliarClases.MyFloat}\pysigline{\strong{class }\code{AuxiliarClases.}\bfcode{MyFloat}}
Bases: \code{float}

differs from float in just the printing method

\end{fulllineitems}

\index{MyInnerTuple (class in AuxiliarClases)}

\begin{fulllineitems}
\phantomsection\label{Analisis/AuxiliarClases:AuxiliarClases.MyInnerTuple}\pysigline{\strong{class }\code{AuxiliarClases.}\bfcode{MyInnerTuple}}
Bases: \code{tuple}

\end{fulllineitems}

\index{MyTuple (class in AuxiliarClases)}

\begin{fulllineitems}
\phantomsection\label{Analisis/AuxiliarClases:AuxiliarClases.MyTuple}\pysigline{\strong{class }\code{AuxiliarClases.}\bfcode{MyTuple}}
Bases: \code{tuple}

differs from tuple in just the printing method

\end{fulllineitems}



\subsection{Auxiliaryfunctions module}
\label{Analisis/Auxiliaryfunctions:auxiliaryfunctions-module}\label{Analisis/Auxiliaryfunctions:module-Auxiliaryfunctions}\label{Analisis/Auxiliaryfunctions::doc}\index{Auxiliaryfunctions (module)}\index{ConstructArray() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.ConstructArray}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{ConstructArray}}{\emph{List\_Arrays}}{}
Reads in a list of arrays, calculates the one with the largest number of elements an storage it in the value Max\_length
completes all the other arrays to that number by filling the missing elements with NaN, after that appends all of them
in the list Array\_handler, convert it to a numpy array and transpose it.
@param List\_Arrays :  a List of lists

\end{fulllineitems}

\index{Convert() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.Convert}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{Convert}}{\emph{X}, \emph{Y}}{}
Fuse the elements of the sublists of X and Y in a tuple and append it to the array `new\_array'
record the number of elements in each sublist in X(Y) in the list dist
@param X   a List of lists contanining floating point elements
@param Y  a List of lists contanining floating point elements

\end{fulllineitems}

\index{F() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.F}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{F}}{\emph{D}, \emph{F1}, \emph{D1}, \emph{D2}, \emph{EfD}, \emph{*args}}{}
\end{fulllineitems}

\index{FindIntersection() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.FindIntersection}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{FindIntersection}}{\emph{BoundaryPoints1}, \emph{BoundaryPoints2}}{}
find the intersection of two sets of intervals A and B whose limit points are stored in BoundaryPoints1 and BoundaryPoints2 respectively.
It is based on the fact that :
\begin{gather}
\begin{split}(\cup_{I \in A} I) \cap (\cup_{J \in B} J) = \cup_{J \in B} (\cup_{I \in A} (J \cap I))\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{FindUnion() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.FindUnion}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{FindUnion}}{\emph{BP1}, \emph{BP2}}{}
\end{fulllineitems}

\index{FormatStart() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.FormatStart}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{FormatStart}}{\emph{Points}}{}
Format the list of Points to account that {[}(0,){]} elements could have been added to by the first iteration, that is the first interval(s) could have a null intersection. But the overall intersection is not, in that cases it deletes the first element.

\end{fulllineitems}

\index{FormatUnionSet() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.FormatUnionSet}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{FormatUnionSet}}{\emph{L}}{}
Glue together the intervals of the sorted List L,sorted in increasing order, if its limits coincide . Each interval is represented by a Tuple . 
It uses a recurse algorithm in which we start at the leftmost position L{[}0{]}, proceed to the right gluing together all the intervals to which it coincide ,i.e. L{[}0{]}{[}1{]} = L{[}i{]}{[}0{]}, it keeps updating L{[}0{]} until it don't found more, and repeat the same procees starting from that position. It terminates when there are no more intervals to add.

\end{fulllineitems}

\index{FormatWidths() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.FormatWidths}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{FormatWidths}}{\emph{Keys}, \emph{WidthDict}}{}
Format Widths using a custom tupple class to get 20 digits printing

\end{fulllineitems}

\index{FormatZones() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.FormatZones}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{FormatZones}}{\emph{Header}, \emph{SZBounds}}{}
Convert each element of the SZBounds into the format used for the InvFunctions dict

\end{fulllineitems}

\index{GetComplement() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.GetComplement}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{GetComplement}}{\emph{Boundaries}, \emph{Min}, \emph{Max}}{}
From a set of Boundary points of a set, return the Boundary Points of its complement. since each one dimensional slide will be a set of intervals it pieces together the complements of each contiguous pair of intervals in each list \(((a,b) \cup (c,d))^c = [b,c]\)

\end{fulllineitems}

\index{GetIntersection() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.GetIntersection}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{GetIntersection}}{\emph{Bound1}, \emph{Bound2}}{}
Get the boundary of the intersection of two sets A and B, by having as input the set of boundary points at each \(x \in xRange\)

\end{fulllineitems}

\index{GetPositiveBoundaries() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.GetPositiveBoundaries}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{GetPositiveBoundaries}}{\emph{PosPoints}, \emph{xRange}}{}
Input a range of Points and for each x in Points a set of tuples containing 
the points of the boundary for the set in which the function has positive
values.
Output a dictionary in the format of the invasibility boundary dicts

\end{fulllineitems}

\index{GetPositiveRegions() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.GetPositiveRegions}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{GetPositiveRegions}}{\emph{Bounds}, \emph{xRange}, \emph{yRange}}{}
\end{fulllineitems}

\index{GetUnion() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.GetUnion}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{GetUnion}}{\emph{Bound1}, \emph{Bound2}}{}
get the boundary points of the union of two sets A and B, having as input the set of boundary points at each \(x \in xRange\)

\end{fulllineitems}

\index{Intersection() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.Intersection}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{Intersection}}{\emph{bp1}, \emph{bp2}}{}
For intervals I and J whose boundary points are given by bp1 and bp2 respectively , returns the boundary points for \(I \cap J\)

\end{fulllineitems}

\index{IntervalInt() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.IntervalInt}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{IntervalInt}}{\emph{bpL}, \emph{bpH}}{}
Find the boundary points of \((a,b) \cap (c,d)\) for which \(a \leq c\)

\end{fulllineitems}

\index{SumBound() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.SumBound}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{SumBound}}{\emph{B}}{}
B is a list of tuples {[}(a1,a2),...{]}, that may contain null elements specified by (0,), get the sum of the difference between the elements of each tuple.

\end{fulllineitems}

\index{addPoints() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.addPoints}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{addPoints}}{\emph{IntPoints}, \emph{NewBPoints}}{}
Add NewBPoints \textbf{N} to the List IntPoints \textbf{I}, only add \(x \in N\) if \(|x[0]|>1 \lor |\mathbf{I}| = 0\)

\end{fulllineitems}

\index{findIntPoints() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.findIntPoints}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{findIntPoints}}{\emph{BoundaryPoints1}, \emph{BoundaryPoint2}}{}
returns the boundary points of \((\cup_{I \in A} (J \cap I))\) for a particular interval \(J\) whose boundary points are given by BoundaryPoint2 and the boundary points of the intervals I are given by the list BoundaryPoints1

\end{fulllineitems}

\index{getCompPoints() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.getCompPoints}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{getCompPoints}}{\emph{boundPoints}, \emph{Min}, \emph{Max}}{}
\end{fulllineitems}

\index{getWidth() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.getWidth}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{getWidth}}{\emph{Boundary}, \emph{*args}}{}
Given the Boundary points of a set D at each location x* in xRange, get the width of the set at the Intersection of (x*,y) and D, it
is assumed that this intersection is a Finite Union of Intervals.

\end{fulllineitems}

\index{inList() (in module Auxiliaryfunctions)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Auxiliaryfunctions:Auxiliaryfunctions.inList}\pysiglinewithargsret{\code{Auxiliaryfunctions.}\bfcode{inList}}{\emph{yPoint}, \emph{ListofTuples}}{}
Returns True if \(y \in T , T \in LoT\) , where \emph{T} is a tuple and \emph{LoT} is a list of tuples

\end{fulllineitems}



\subsection{Baseclass module}
\label{Analisis/Baseclass::doc}\label{Analisis/Baseclass:baseclass-module}\label{Analisis/Baseclass:module-Baseclass}\index{Baseclass (module)}\index{BSR (class in Baseclass)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR}\pysiglinewithargsret{\strong{class }\code{Baseclass.}\bfcode{BSR}}{\emph{params}, \emph{mode}, \emph{xLims}, \emph{ksim=True}}{}
Bases: \code{object}

Class that stores the basic information for the analysis such as:
* The mode of the ODE system(RM or LV)
* The approach(Top down or bottom up)
* Generate the dictionary with all the functions and the x and y ranges that will be explored.
* ksim is a boolean variable that set the assumption about similar or not body size ratios across trophic levels.
* In the case of the Active-Grazing-Grazing strategy, it exists a singular point in the x axis when ksim is false, in this case we set a finer xrange
in points near to it, this is stored in the xFocus\_sep variable.
\index{getParams() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.getParams}\pysiglinewithargsret{\bfcode{getParams}}{}{}
\end{fulllineitems}

\index{getandSetxFocus() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.getandSetxFocus}\pysiglinewithargsret{\bfcode{getandSetxFocus}}{\emph{nPoints}, \emph{dist}}{}
nPoints : the number of points in which the interval {[}x0-dist,x0{]} is going to be divided, x0 is where the singularity occurres (if it exists)

\end{fulllineitems}

\index{getfDict() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.getfDict}\pysiglinewithargsret{\bfcode{getfDict}}{}{}
return the dictionary of functions

\end{fulllineitems}

\index{getmode() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.getmode}\pysiglinewithargsret{\bfcode{getmode}}{}{}
return the mode of the analysis, possible answers at the moment are LV and RM

\end{fulllineitems}

\index{getxLims() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.getxLims}\pysiglinewithargsret{\bfcode{getxLims}}{}{}
return the boundary points of the xRange list(assumed as an Interval)

\end{fulllineitems}

\index{setInvFunctions() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.setInvFunctions}\pysiglinewithargsret{\bfcode{setInvFunctions}}{}{}
\end{fulllineitems}

\index{setfDict() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.setfDict}\pysiglinewithargsret{\bfcode{setfDict}}{}{}
Constructs the dictionary containing all the elementary functions used in the analysis
Separates two different approachs:
if bottom is true  m\_C and m\_P are expressed in terms of m\_R, else m\_C and m\_R are expressed in terms of m\_P, in reality the scenarios will give
similar pictures, we are just rotating the plane if we interchange them

\end{fulllineitems}

\index{setxFocus() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.setxFocus}\pysiglinewithargsret{\bfcode{setxFocus}}{\emph{focusLims}}{}
\end{fulllineitems}

\index{setxFocusSep() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.setxFocusSep}\pysiglinewithargsret{\bfcode{setxFocusSep}}{\emph{Focus\_sep}}{}
\end{fulllineitems}

\index{setxRange() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.setxRange}\pysiglinewithargsret{\bfcode{setxRange}}{}{}
Sets the range of X points which are going to be explored

\end{fulllineitems}

\index{setyRange() (Baseclass.BSR method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/Baseclass:Baseclass.BSR.setyRange}\pysiglinewithargsret{\bfcode{setyRange}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{ExploreParams module}
\label{Analisis/ExploreParams:module-ExploreParams}\label{Analisis/ExploreParams::doc}\label{Analisis/ExploreParams:exploreparams-module}\index{ExploreParams (module)}\index{AddToCombinations() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.AddToCombinations}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{AddToCombinations}}{\emph{param}, \emph{ParamsToExplore}, \emph{AuxiliarParams}, \emph{SpecialParams}, \emph{Combinations}}{}
From a base set List of Combinations, update it using the values stored in ParamsToExplore{[}param{]}, AuxiliarParams{[}param{]}

\end{fulllineitems}

\index{AddValtoComb() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.AddValtoComb}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{AddValtoComb}}{\emph{Comb}, \emph{val}, \emph{param}, \emph{AuxiliarParams}, \emph{SpecialParams}}{}
Find all the associate parameter combinations given a particular value val of the parameter `param'.
This is donde in a recursive way, the depth of the recursion is finite since the number of keys for AuxiliarParams is finite.
If param is a SpecialParam, it adds the low level representation of it to Comb.
Finally it updates each of the combinations found with Comb and returns it.

\end{fulllineitems}

\index{ConstructDir() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.ConstructDir}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{ConstructDir}}{\emph{ParamDict}, \emph{mode}, \emph{ParamsDirCoder}, \emph{Type}}{}
\end{fulllineitems}

\index{CreateDirCoder() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.CreateDirCoder}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{CreateDirCoder}}{\emph{ParamsToExplore}, \emph{dimDict}}{}
ParamsToExplore is a dictionary with parameter names as keys and a list of values as values
dimDict

\end{fulllineitems}

\index{CreateTxtCoder() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.CreateTxtCoder}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{CreateTxtCoder}}{\emph{ParamsDirCoder}, \emph{direction}}{}
\end{fulllineitems}

\index{EvaluateParams() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.EvaluateParams}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{EvaluateParams}}{\emph{paramdict}, \emph{combination}, \emph{mode}, \emph{xlims}, \emph{HeaderInv}, \emph{ParamsDirCoder}, \emph{Direction}, \emph{ksim}, \emph{mass}}{}
For a given dict of parameters:
* calculate the invasibility boundaries, the Equilibrium, eigenvalues ,MTP, Zones and width of the zones for (x,y) values between \(xRange \times [-10,5]\)
* Write the results to csv files

\end{fulllineitems}

\index{ExploreParamSpace() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.ExploreParamSpace}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{ExploreParamSpace}}{\emph{InitDict, ParamsToExplore, TotalParams, xlims, mode, HeaderInv, AuxiliarParams, SpecialParams, dimDict, initDirection, ksim=True, massVals={[}0{]}}}{}
Explore the parameter space, by first constructing the total params combinations to explore , creating a Dict that contains a name for each combination
and then Evaluating and Saving each of the parameter combinations

\end{fulllineitems}

\index{MakeTotalParamsCombination() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.MakeTotalParamsCombination}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{MakeTotalParamsCombination}}{\emph{ParamsToExplore}, \emph{AuxiliarParams}, \emph{SpecialParams}}{}~\begin{itemize}
\item {} 
ParamsToExplore is a dictionary with parameter names as keys and a list of values as Values

\item {} 
AuxiliarParams is a dictionary that stores the information about correlated parameters, that is we set K to a value K0 we must also change the values of the params specified in this dict to the respective values.

\item {} 
SpecialParams refer to a superClass of Params which are defined as combinations of the elementary params , e.g Comb1:= \{`fmC':Grazing,'fmPC':Active,'fmPR':Grazing\}

\end{itemize}

returns a list of Dictionaries containing all possible combinantions for the given params

\end{fulllineitems}

\index{UpdateComb() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.UpdateComb}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{UpdateComb}}{\emph{Comb}, \emph{combinations}}{}
Update each dictiondary in \emph{combinations} with the dictionary \emph{Comb}.

\end{fulllineitems}

\index{setMassTag() (in module ExploreParams)}

\begin{fulllineitems}
\phantomsection\label{Analisis/ExploreParams:ExploreParams.setMassTag}\pysiglinewithargsret{\code{ExploreParams.}\bfcode{setMassTag}}{\emph{mass}}{}
\end{fulllineitems}



\subsection{ExploreParamsProgram module}
\label{Analisis/ExploreParamsProgram:exploreparamsprogram-module}\label{Analisis/ExploreParamsProgram::doc}\label{Analisis/ExploreParamsProgram:module-ExploreParamsProgram}\index{ExploreParamsProgram (module)}

\subsection{InvasionAnalysis module}
\label{Analisis/InvasionAnalysis::doc}\label{Analisis/InvasionAnalysis:module-InvasionAnalysis}\label{Analisis/InvasionAnalysis:invasionanalysis-module}\index{InvasionAnalysis (module)}\index{InvBoundaries (class in InvasionAnalysis)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries}\pysiglinewithargsret{\strong{class }\code{InvasionAnalysis.}\bfcode{InvBoundaries}}{\emph{workingData}, \emph{currentMass=0.0}}{}
Bases: {\hyperref[Analisis/Baseclass:Baseclass.BSR]{\code{Baseclass.BSR}}}

Class that stores and computes the values for the invasibility boundaries of the distinct scenarios, it receives as initial
input the values of the parameters and the invasibility functions
\index{InvBoundary() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.InvBoundary}\pysiglinewithargsret{\bfcode{InvBoundary}}{\emph{Invfunc}, \emph{searchRange}, \emph{xRange}}{}
Find the inv boundaries(zeros of the invasibility function) using the brentq method from the SciPy package,
input arguments, the invasibility function, the limits for the interval to look for zeros(depending on the x values)

\end{fulllineitems}

\index{UpdateMass() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.UpdateMass}\pysiglinewithargsret{\bfcode{UpdateMass}}{\emph{newMass}}{}
\end{fulllineitems}

\index{WriteWidths() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.WriteWidths}\pysiglinewithargsret{\bfcode{WriteWidths}}{\emph{Direction}}{}
Write the Width dictionary to a file specified in Direction.

\end{fulllineitems}

\index{WriteZonesBounds() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.WriteZonesBounds}\pysiglinewithargsret{\bfcode{WriteZonesBounds}}{\emph{Direction}}{}
Write the SZBounds into a file whose pointer is specified in Direction.

\end{fulllineitems}

\index{findWidths() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.findWidths}\pysiglinewithargsret{\bfcode{findWidths}}{}{}
Find the widths of each of the Zones

\end{fulllineitems}

\index{findZones() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.findZones}\pysiglinewithargsret{\bfcode{findZones}}{}{}
From each of the Boundaries, create a 2D array using xRange and yRange and return a 1 0  array , each 1 located at a position in which
the point is interior to the Positive Region delimited by the Boundary

\end{fulllineitems}

\index{findZonesBoundaries() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.findZonesBoundaries}\pysiglinewithargsret{\bfcode{findZonesBoundaries}}{}{}
Find the boundary of the Zones and format them to the same data structure used in the computation of the Invasibility boundaries

\end{fulllineitems}

\index{getBounds() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.getBounds}\pysiglinewithargsret{\bfcode{getBounds}}{}{}
return the dictionary containing all the invasibility boundaries

\end{fulllineitems}

\index{setAndWriteInvBoundaries() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.setAndWriteInvBoundaries}\pysiglinewithargsret{\bfcode{setAndWriteInvBoundaries}}{\emph{Header}, \emph{Direction}}{}~\begin{itemize}
\item {} 
Find the zero boundaries for each of the functions specified in self.InvFunctions

\item {} 
Write them to a csv file specified in Direction.

\end{itemize}

Header refers to the first row of the csv file.

\end{fulllineitems}

\index{setAndWriteWidthsZones() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.setAndWriteWidthsZones}\pysiglinewithargsret{\bfcode{setAndWriteWidthsZones}}{\emph{DirectionW}, \emph{DirectionZB}, \emph{DirectionZones}}{}~\begin{itemize}
\item {} 
For each x in xRange and any Invasibility function f calculates the sum of the length of all the intervals which are in the Positive region of f

\item {} 
Get the Positive Boundaries for all the target zones in the analysis

\item {} 
Write both of the above results to a file whose direction is specified in the arguments DirectionW and DirectionZ.

\end{itemize}

\end{fulllineitems}

\index{setIntersections() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.setIntersections}\pysiglinewithargsret{\bfcode{setIntersections}}{}{}
Find the boundary points of the Intersections of the Positive Regions of some invasibility functions, which delineate the zones expressed in the analysis.
For example \(Z(I_{C4}) := Z(I_{C2}) \cap PR_{4}\) where \(PR_{4}\) is the set for which the Invasibility function I\_P\_s4 is positive.
We assume that one dimensional subset of the set are always a union of emph\{connected\} sets.

\end{fulllineitems}

\index{setInvBoundaries() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.setInvBoundaries}\pysiglinewithargsret{\bfcode{setInvBoundaries}}{}{}
For each of the functions present in the InvFunctions list, computes the invasibility boundaries by means of the
Scipy.Brentq numerical method.
For each of the invasibility functions it returns a dict object with x and y keys indicating the zeros(size ratio values delimiting
the boundaries) for the function at each x (mass), the values of x and y are a list of lists. the total number of sublists denotes the maximum
number of zeros found at any location x.
if e1e3 - e2 = EfDif \textless{}0 it also computes the boundaries for the D function

\end{fulllineitems}

\index{setPositiveBoundaries() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.setPositiveBoundaries}\pysiglinewithargsret{\bfcode{setPositiveBoundaries}}{}{}
Creates a dict storying the boundary points of the set in which each of the criterions is satisfied

\end{fulllineitems}

\index{setUpGuess() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.setUpGuess}\pysiglinewithargsret{\bfcode{setUpGuess}}{\emph{Guess}}{}
\end{fulllineitems}

\index{setWidthsAndZones() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.setWidthsAndZones}\pysiglinewithargsret{\bfcode{setWidthsAndZones}}{}{}~\begin{itemize}
\item {} 
Calculates the Boundaries of the Zones described in the Study, which are intersection of the Positive Regions of a subset of the Invasibility functions

\item {} 
Calculates the widths of each of the Zones

\item {} 
Convert them to the format used for the Invasibility functions and save them in the ZBounds dict

\item {} 
if EfDif\textless{}0 , calculates the boundary for the stable coexistence zone.

\end{itemize}

\end{fulllineitems}

\index{writeInvasibilityValues() (InvasionAnalysis.InvBoundaries method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/InvasionAnalysis:InvasionAnalysis.InvBoundaries.writeInvasibilityValues}\pysiglinewithargsret{\bfcode{writeInvasibilityValues}}{\emph{Header}, \emph{direction}, \emph{delimiter='}, \emph{`}}{}
Write data into a csv file specified in direction
@param Boundaries a list of 2-elements lists which each of them stores the X and Y coordinates
of the invasibility boundaries computed in the analysis
@param the list of params used to compute the boundaries which will be used in the footer of the csv file
@direction the system direction where the file is going to be stored
@Header the first row of the csv file

\end{fulllineitems}


\end{fulllineitems}



\subsection{OutputClasses module}
\label{Analisis/OutputClasses:module-OutputClasses}\label{Analisis/OutputClasses::doc}\label{Analisis/OutputClasses:outputclasses-module}\index{OutputClasses (module)}\index{Data (class in OutputClasses)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.Data}\pysiglinewithargsret{\strong{class }\code{OutputClasses.}\bfcode{Data}}{\emph{data}}{}
Bases: \code{object}

Class that stores a dataset in the format of a n x n matrix
\index{TransformtoFloats() (OutputClasses.Data method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.Data.TransformtoFloats}\pysiglinewithargsret{\bfcode{TransformtoFloats}}{}{}
\end{fulllineitems}

\index{getrow() (OutputClasses.Data method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.Data.getrow}\pysiglinewithargsret{\bfcode{getrow}}{\emph{index}}{}
\end{fulllineitems}

\index{ncols() (OutputClasses.Data method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.Data.ncols}\pysiglinewithargsret{\bfcode{ncols}}{}{}
\end{fulllineitems}

\index{nrows() (OutputClasses.Data method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.Data.nrows}\pysiglinewithargsret{\bfcode{nrows}}{}{}
\end{fulllineitems}

\index{reshape() (OutputClasses.Data method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.Data.reshape}\pysiglinewithargsret{\bfcode{reshape}}{}{}
\end{fulllineitems}

\index{setData() (OutputClasses.Data method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.Data.setData}\pysiglinewithargsret{\bfcode{setData}}{\emph{Data}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{OutputInvData (class in OutputClasses)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.OutputInvData}\pysiglinewithargsret{\strong{class }\code{OutputClasses.}\bfcode{OutputInvData}}{\emph{data}, \emph{header}, \emph{footer}, \emph{xFocusAndSep}, \emph{distribution}}{}
Bases: {\hyperref[Analisis/OutputClasses:OutputClasses.Data]{\code{OutputClasses.Data}}}

Creates an abstraction of a csv table, with a header and footer.
data stores all the body of the table
distribution is a tuple whose length referes to the number of parts which has been put together
in the column, and each component of it referees to the number of items in each part
\index{WriteEquilibrium() (OutputClasses.OutputInvData method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.OutputInvData.WriteEquilibrium}\pysiglinewithargsret{\bfcode{WriteEquilibrium}}{\emph{direction}, \emph{delimiter}}{}
\end{fulllineitems}

\index{WriteInvasibility() (OutputClasses.OutputInvData method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.OutputInvData.WriteInvasibility}\pysiglinewithargsret{\bfcode{WriteInvasibility}}{\emph{direction}, \emph{delimiter}}{}
Make use of the csv module to produce an csv file with the data contained in self.data

\end{fulllineitems}

\index{WriteWidths() (OutputClasses.OutputInvData method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.OutputInvData.WriteWidths}\pysiglinewithargsret{\bfcode{WriteWidths}}{\emph{direction}, \emph{delimiter}}{}
\end{fulllineitems}

\index{setFooter() (OutputClasses.OutputInvData method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.OutputInvData.setFooter}\pysiglinewithargsret{\bfcode{setFooter}}{\emph{footer}}{}
\end{fulllineitems}

\index{setHeader() (OutputClasses.OutputInvData method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.OutputInvData.setHeader}\pysiglinewithargsret{\bfcode{setHeader}}{\emph{header}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{constructFooter() (in module OutputClasses)}

\begin{fulllineitems}
\phantomsection\label{Analisis/OutputClasses:OutputClasses.constructFooter}\pysiglinewithargsret{\code{OutputClasses.}\bfcode{constructFooter}}{\emph{params}}{}
\end{fulllineitems}



\subsection{RMEquibrium module}
\label{Analisis/RMEquibrium::doc}\label{Analisis/RMEquibrium:rmequibrium-module}\label{Analisis/RMEquibrium:module-RMEquibrium}\index{RMEquibrium (module)}\index{AddPoints() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.AddPoints}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{AddPoints}}{\emph{BreakPoints}, \emph{yList}, \emph{n}, \emph{maxY}, \emph{minY}, \emph{Type}}{}
From a list of zeros determine the ones that delimit a pass from positive to negative and store them in a list, i.e. find the boundary points
of the positive region

\end{fulllineitems}

\index{AddToBoundaryPoints() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.AddToBoundaryPoints}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{AddToBoundaryPoints}}{\emph{BreakPoints}, \emph{xPoint}, \emph{xList}, \emph{yList}, \emph{f}, \emph{maxY}, \emph{minY}, \emph{ksim}, \emph{arg1}}{}
\end{fulllineitems}

\index{ExtractPoints() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.ExtractPoints}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{ExtractPoints}}{\emph{xRanges}, \emph{BoundaryPoints}}{}
\end{fulllineitems}

\index{FindCoexistenceRegion() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.FindCoexistenceRegion}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{FindCoexistenceRegion}}{\emph{self}}{}
\end{fulllineitems}

\index{FindRPositiveRegion() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.FindRPositiveRegion}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{FindRPositiveRegion}}{\emph{self}}{}
\end{fulllineitems}

\index{FindpositiveRegion() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.FindpositiveRegion}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{FindpositiveRegion}}{\emph{self}, \emph{Pred}}{}
\end{fulllineitems}

\index{GetGuessBounds() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.GetGuessBounds}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{GetGuessBounds}}{\emph{Arr}, \emph{Arr2}, \emph{f}, \emph{defaultUpGuess}, \emph{defaultLowGuess}, \emph{ksim}, \emph{arg1}}{}
Code for delimiting the boundaries of the positive region of a given function

\end{fulllineitems}

\index{isNegative() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.isNegative}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{isNegative}}{\emph{f}, \emph{xPoint}, \emph{yPoint}, \emph{ksim}, \emph{arg1}}{}
\end{fulllineitems}

\index{toDict() (in module RMEquibrium)}

\begin{fulllineitems}
\phantomsection\label{Analisis/RMEquibrium:RMEquibrium.toDict}\pysiglinewithargsret{\code{RMEquibrium.}\bfcode{toDict}}{\emph{xRanges}, \emph{BPoints}}{}
\end{fulllineitems}



\subsection{SimulationDynamics module}
\label{Analisis/SimulationDynamics:simulationdynamics-module}\label{Analisis/SimulationDynamics::doc}\label{Analisis/SimulationDynamics:module-SimulationDynamics}\index{SimulationDynamics (module)}\index{Dynamics (class in SimulationDynamics)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics}\pysiglinewithargsret{\strong{class }\code{SimulationDynamics.}\bfcode{Dynamics}}{\emph{workingData}, \emph{initCondition}, \emph{finalTime}, \emph{separation}, \emph{K\_CP}, \emph{K\_RC}, \emph{m\_P}}{}
Bases: {\hyperref[Analisis/Baseclass:Baseclass.BSR]{\code{Baseclass.BSR}}}
\index{DynamicFunction() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.DynamicFunction}\pysiglinewithargsret{\bfcode{DynamicFunction}}{\emph{X}, \emph{t}}{}
\end{fulllineitems}

\index{Simulate() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.Simulate}\pysiglinewithargsret{\bfcode{Simulate}}{}{}
simulation routine using the Odeint solver from the scipy optimize package , Odeint is a python implementation
of the ODEPACK package in FORTRAN which uses a multi-step solver in the non stiff case

\end{fulllineitems}

\index{makeinitCondition() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.makeinitCondition}\pysiglinewithargsret{\bfcode{makeinitCondition}}{\emph{case}}{}
se the init condition , depending on the scenario , in the Invasibility by P to C-R the initial condition
is the equilibrium of the latter two in isolation , a similar situation is for the invasibility of C to P-R(labeled 
scenario 5)

\end{fulllineitems}

\index{runSimulationSimK() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.runSimulationSimK}\pysiglinewithargsret{\bfcode{runSimulationSimK}}{\emph{case}, \emph{massLims}, \emph{lowKLims}, \emph{upKLims}, \emph{initDirection}}{}
\end{fulllineitems}

\index{setDynamicFunction() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.setDynamicFunction}\pysiglinewithargsret{\bfcode{setDynamicFunction}}{}{}
input the corresponding values for the paramters K\_CP, K\_RC and m\_P and convert the dynamical functions dR, dC 
and dP in three-argument functions, just depending on the value of the biomass densities R, C and P

\end{fulllineitems}

\index{setParamVals() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.setParamVals}\pysiglinewithargsret{\bfcode{setParamVals}}{\emph{K\_CP}, \emph{K\_RC}, \emph{m\_P}}{}
Set the values for the three key paramaters of the model , the size ratios and the body mass

\end{fulllineitems}

\index{setfinalTime() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.setfinalTime}\pysiglinewithargsret{\bfcode{setfinalTime}}{\emph{finalTime}}{}
set the time until when to stop the simulation

\end{fulllineitems}

\index{setinitCondition() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.setinitCondition}\pysiglinewithargsret{\bfcode{setinitCondition}}{\emph{initCondition}}{}
Specifices the given initial condition from which to start the simulation

\end{fulllineitems}

\index{setseparation() (SimulationDynamics.Dynamics method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/SimulationDynamics:SimulationDynamics.Dynamics.setseparation}\pysiglinewithargsret{\bfcode{setseparation}}{\emph{separation}}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{TestProgram module}
\label{Analisis/TestProgram:testprogram-module}\label{Analisis/TestProgram::doc}\label{Analisis/TestProgram:module-TestProgram}\index{TestProgram (module)}\index{Test() (in module TestProgram)}

\begin{fulllineitems}
\phantomsection\label{Analisis/TestProgram:TestProgram.Test}\pysiglinewithargsret{\code{TestProgram.}\bfcode{Test}}{\emph{params}, \emph{ksim}, \emph{xRange}, \emph{DirEq}, \emph{DirStab}, \emph{DirMTP}, \emph{DirInv}, \emph{type='LV'}, \emph{mass=1e-10}}{}
\end{fulllineitems}



\subsection{bounds module}
\label{Analisis/bounds:bounds-module}\label{Analisis/bounds:module-bounds}\label{Analisis/bounds::doc}\index{bounds (module)}\index{Cubic (class in bounds)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Cubic}\pysiglinewithargsret{\strong{class }\code{bounds.}\bfcode{Cubic}}{\emph{a}, \emph{b}, \emph{c}, \emph{d}}{}
Bases: \code{object}
\index{Evaluate() (bounds.Cubic method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Cubic.Evaluate}\pysiglinewithargsret{\bfcode{Evaluate}}{\emph{x}}{}
\end{fulllineitems}

\index{derivativeEvaluate() (bounds.Cubic method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Cubic.derivativeEvaluate}\pysiglinewithargsret{\bfcode{derivativeEvaluate}}{\emph{x}}{}
\end{fulllineitems}

\index{getGeometricDiscriminant() (bounds.Cubic method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Cubic.getGeometricDiscriminant}\pysiglinewithargsret{\bfcode{getGeometricDiscriminant}}{}{}
\end{fulllineitems}

\index{getRealRoots() (bounds.Cubic method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Cubic.getRealRoots}\pysiglinewithargsret{\bfcode{getRealRoots}}{}{}
\end{fulllineitems}

\index{setYn() (bounds.Cubic method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Cubic.setYn}\pysiglinewithargsret{\bfcode{setYn}}{}{}
\end{fulllineitems}

\index{setdelta2() (bounds.Cubic method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Cubic.setdelta2}\pysiglinewithargsret{\bfcode{setdelta2}}{}{}
\end{fulllineitems}

\index{seth2() (bounds.Cubic method)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Cubic.seth2}\pysiglinewithargsret{\bfcode{seth2}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Get\_bounds() (in module bounds)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Get_bounds}\pysiglinewithargsret{\code{bounds.}\bfcode{Get\_bounds}}{\emph{f}, \emph{get\_roots}, \emph{m\_range}, \emph{upper\_guess}, \emph{lower\_guess}, \emph{k\_2\_range={[}{]}}, \emph{k\_sim=True}, \emph{debug=False}, \emph{sep=0.05}}{}
\end{fulllineitems}

\index{Get\_bounds2() (in module bounds)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Get_bounds2}\pysiglinewithargsret{\code{bounds.}\bfcode{Get\_bounds2}}{\emph{f}, \emph{get\_roots}, \emph{x\_range}, \emph{search\_range}, \emph{additionalPar=0}, \emph{k\_sim=True}, \emph{debug=False}}{}
Search for the zeros of the function f  using the brentq optimization algorithm, separates two cases:
\begin{itemize}
\item {} 
k\_sim is true : f is a bivariate function and the additional argument is given by x\_range{[}i{]}

\item {} 
k\_sim is false: f is a trivariate function and the additinal arguments are given by (x\_range{[}i{]},additionalPar)

\end{itemize}

\end{fulllineitems}

\index{Roots() (in module bounds)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.Roots}\pysiglinewithargsret{\code{bounds.}\bfcode{Roots}}{\emph{mass}, \emph{lower\_guess}, \emph{upper\_guess}, \emph{sep}, \emph{f}, \emph{get\_roots}}{}
\end{fulllineitems}

\index{plot\_() (in module bounds)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.plot_}\pysiglinewithargsret{\code{bounds.}\bfcode{plot\_}}{\emph{x}, \emph{y}, \emph{ax}, \emph{label}, \emph{color='b'}, \emph{log=True}, \emph{marker='o'}, \emph{linestyle='-`}}{}
\end{fulllineitems}

\index{procce\_() (in module bounds)}

\begin{fulllineitems}
\phantomsection\label{Analisis/bounds:bounds.procce_}\pysiglinewithargsret{\code{bounds.}\bfcode{procce\_}}{\emph{Arr}, \emph{Arr2}}{}
\end{fulllineitems}



\subsection{roots module}
\label{Analisis/roots:roots-module}\label{Analisis/roots:module-roots}\label{Analisis/roots::doc}\index{roots (module)}\index{Get\_roots() (in module roots)}

\begin{fulllineitems}
\phantomsection\label{Analisis/roots:roots.Get_roots}\pysiglinewithargsret{\code{roots.}\bfcode{Get\_roots}}{\emph{f}, \emph{arg}, \emph{array}, \emph{j=0}, \emph{debug=False}, \emph{method=\textless{}function brentq at 0x000000000A0AB748\textgreater{}}}{}
Search for the all the zeros of a continuos and smooth function f, using the brentq optimization algorithm
* Assumes that there is at most one zero in any of the subintervals (x{[}i{]},x{[}i+1{]}), where d(x{[}i+1{]},x{[}i{]}) \textless{}=0.03

The way it performs the search is the following:
1) Computes F\_array using the function f, array and any other arguments that the functions needs(This means that f could be a multivariate function,
but we are just fixing a subset of a line in which to search), this arguments are formated by the createArray function and we are making use of the convenient
way python functions handle numpy arrays.
2) set a inital index j to 0
3) Starts at F\_array{[}j{]} computes the sign of it, proceed through the elements of F\_array until it founds i such that sign(F\_array{[}j{]}) != sign(F\_array{[}i{]}) 
4) apply the brentq method to the interval array{[}j{]},array{[}i{]} and give all the necessary arguments.
5) changes j to i
6) Repeats steps 3-4-5 until there are no more elements in F\_array

\end{fulllineitems}

\index{createArray() (in module roots)}

\begin{fulllineitems}
\phantomsection\label{Analisis/roots:roots.createArray}\pysiglinewithargsret{\code{roots.}\bfcode{createArray}}{\emph{args}, \emph{baseArray}}{}
Create a list of np.arrays whose values are all the same, using the values stored in args

\end{fulllineitems}



\chapter{Model-Construction.Parametrization}
\label{Model-Construction/modules:model-construction-parametrization}\label{Model-Construction/modules::doc}

\section{Specifications}
\label{Model-Construction/modules:specifications}\begin{itemize}
\item {} 
This modules define the functions for a set of models(atm \emph{lotka volterra} and \emph{rozenweigh macArthur}) and store it in a dictionary format for future use.

\end{itemize}


\section{Contents}
\label{Model-Construction/modules:contents}

\subsection{Dynamics module}
\label{Model-Construction/Dynamics:module-Dynamics}\label{Model-Construction/Dynamics:dynamics-module}\label{Model-Construction/Dynamics::doc}\index{Dynamics (module)}\index{set\_dCLV() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dCLV}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dCLV}}{\emph{R}, \emph{C}, \emph{P}, \emph{a1}, \emph{a3}, \emph{e1}, \emph{q1}, \emph{m\_C}, \emph{m\_P}}{}
\end{fulllineitems}

\index{set\_dCRM() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dCRM}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dCRM}}{\emph{R}, \emph{C}, \emph{P}, \emph{a1}, \emph{a3}, \emph{e1}, \emph{t\_hc}, \emph{t\_hp}, \emph{q1}, \emph{m\_C}, \emph{m\_P}}{}
\end{fulllineitems}

\index{set\_dPLV() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dPLV}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dPLV}}{\emph{R}, \emph{C}, \emph{P}, \emph{a2}, \emph{a3}, \emph{e2}, \emph{e3}, \emph{q2}, \emph{m\_P}}{}
\end{fulllineitems}

\index{set\_dPRM() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dPRM}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dPRM}}{\emph{R}, \emph{C}, \emph{P}, \emph{a2}, \emph{a3}, \emph{e2}, \emph{e3}, \emph{t\_hp}, \emph{q2}, \emph{m\_P}}{}
\end{fulllineitems}

\index{set\_dPredLV() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dPredLV}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dPredLV}}{\emph{R}, \emph{Pred}, \emph{a}, \emph{e}, \emph{m}, \emph{q}}{}
\end{fulllineitems}

\index{set\_dRLV() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dRLV}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dRLV}}{\emph{R}, \emph{C}, \emph{P}, \emph{r}, \emph{K}, \emph{a1}, \emph{a2}, \emph{m\_C}, \emph{m\_P}}{}
\end{fulllineitems}

\index{set\_dRLVPart() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dRLVPart}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dRLVPart}}{\emph{R}, \emph{Pred}, \emph{r}, \emph{K}, \emph{a}, \emph{m}}{}
\end{fulllineitems}

\index{set\_dRRM() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dRRM}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dRRM}}{\emph{R}, \emph{C}, \emph{P}, \emph{r}, \emph{K}, \emph{a1}, \emph{a2}, \emph{t\_hp}, \emph{t\_hc}, \emph{m\_C}, \emph{m\_P}}{}
\end{fulllineitems}

\index{set\_dRalone() (in module Dynamics)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Dynamics:Dynamics.set_dRalone}\pysiglinewithargsret{\code{Dynamics.}\bfcode{set\_dRalone}}{\emph{R}, \emph{r}, \emph{K}}{}
\end{fulllineitems}



\subsection{Eq module}
\label{Model-Construction/Eq::doc}\label{Model-Construction/Eq:eq-module}\label{Model-Construction/Eq:module-Eq}\index{Eq (module)}\index{setD() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setD}\pysiglinewithargsret{\code{Eq.}\bfcode{setD}}{\emph{K}, \emph{a\_1}, \emph{a\_2}, \emph{a\_3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{m\_C}, \emph{r}}{}
\end{fulllineitems}

\index{setDBound() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setDBound}\pysiglinewithargsret{\code{Eq.}\bfcode{setDBound}}{\emph{K}, \emph{a\_1}, \emph{a\_2}, \emph{a\_3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{m\_C}, \emph{r}}{}
\end{fulllineitems}

\index{setDis() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setDis}\pysiglinewithargsret{\code{Eq.}\bfcode{setDis}}{\emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a1}, \emph{a2}, \emph{a3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{thc}, \emph{thp}, \emph{mP}, \emph{mC}, \emph{q2\_0}, \emph{q1\_0}, \emph{hC\_0}, \emph{hP\_0}}{}
\end{fulllineitems}

\index{setEqCDen\_RM() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setEqCDen_RM}\pysiglinewithargsret{\code{Eq.}\bfcode{setEqCDen\_RM}}{\emph{e\_3}, \emph{q2\_0}, \emph{hP\_0}}{}
\end{fulllineitems}

\index{setEqCNum\_RM() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setEqCNum_RM}\pysiglinewithargsret{\code{Eq.}\bfcode{setEqCNum\_RM}}{\emph{q\_2}, \emph{mP}, \emph{a2}, \emph{R}, \emph{e\_2}, \emph{q2\_0}, \emph{hP\_0}}{}
\end{fulllineitems}

\index{setEqPDen\_RM() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setEqPDen_RM}\pysiglinewithargsret{\code{Eq.}\bfcode{setEqPDen\_RM}}{\emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a1}, \emph{a2}, \emph{a3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{thc}, \emph{thp}, \emph{R}, \emph{C}, \emph{P}, \emph{mP}, \emph{mC}, \emph{q2\_0}, \emph{q1\_0}, \emph{hC\_0}, \emph{hP\_0}}{}
\end{fulllineitems}

\index{setEqPNum\_RM() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setEqPNum_RM}\pysiglinewithargsret{\code{Eq.}\bfcode{setEqPNum\_RM}}{\emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a1}, \emph{a2}, \emph{a3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{thc}, \emph{thp}, \emph{R}, \emph{C}, \emph{P}, \emph{mP}, \emph{mC}, \emph{q2\_0}, \emph{q1\_0}, \emph{hC\_0}, \emph{hP\_0}}{}
\end{fulllineitems}

\index{setRoot1() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setRoot1}\pysiglinewithargsret{\code{Eq.}\bfcode{setRoot1}}{\emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a1}, \emph{a2}, \emph{a3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{thc}, \emph{thp}, \emph{mP}, \emph{mC}, \emph{q2\_0}, \emph{q1\_0}, \emph{hC\_0}, \emph{hP\_0}}{}
\end{fulllineitems}

\index{set\_C\_eq() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.set_C_eq}\pysiglinewithargsret{\code{Eq.}\bfcode{set\_C\_eq}}{\emph{m\_P}, \emph{m\_C}, \emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a\_1}, \emph{a\_2}, \emph{a\_3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}}{}
\end{fulllineitems}

\index{set\_P\_eq() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.set_P_eq}\pysiglinewithargsret{\code{Eq.}\bfcode{set\_P\_eq}}{\emph{m\_P}, \emph{m\_C}, \emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a\_1}, \emph{a\_2}, \emph{a\_3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}}{}
\end{fulllineitems}

\index{set\_R\_eq() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.set_R_eq}\pysiglinewithargsret{\code{Eq.}\bfcode{set\_R\_eq}}{\emph{m\_P}, \emph{m\_C}, \emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a\_1}, \emph{a\_2}, \emph{a\_3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}}{}
\end{fulllineitems}

\index{setb\_R() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setb_R}\pysiglinewithargsret{\code{Eq.}\bfcode{setb\_R}}{\emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a1}, \emph{a2}, \emph{a3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{thc}, \emph{thp}, \emph{mP}, \emph{mC}, \emph{q2\_0}, \emph{q1\_0}, \emph{hC\_0}, \emph{hP\_0}}{}
\end{fulllineitems}

\index{setden\_R() (in module Eq)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Eq:Eq.setden_R}\pysiglinewithargsret{\code{Eq.}\bfcode{setden\_R}}{\emph{K}, \emph{q\_1}, \emph{q\_2}, \emph{r}, \emph{a1}, \emph{a2}, \emph{a3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{thc}, \emph{thp}, \emph{mP}, \emph{mC}, \emph{q2\_0}, \emph{q1\_0}, \emph{hC\_0}, \emph{hP\_0}}{}
\end{fulllineitems}



\subsection{Equilibrium module}
\label{Model-Construction/Equilibrium::doc}\label{Model-Construction/Equilibrium:module-Equilibrium}\label{Model-Construction/Equilibrium:equilibrium-module}\index{Equilibrium (module)}\index{Cramers\_L\_solver() (in module Equilibrium)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/Equilibrium:Equilibrium.Cramers_L_solver}\pysiglinewithargsret{\code{Equilibrium.}\bfcode{Cramers\_L\_solver}}{\emph{E}, \emph{B}, \emph{j}}{}
\end{fulllineitems}



\subsection{MTP module}
\label{Model-Construction/MTP:mtp-module}\label{Model-Construction/MTP:module-MTP}\label{Model-Construction/MTP::doc}\index{MTP (module)}\index{MTP\_O() (in module MTP)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/MTP:MTP.MTP_O}\pysiglinewithargsret{\code{MTP.}\bfcode{MTP\_O}}{\emph{P\_eq}, \emph{C\_eq}, \emph{R\_eq}, \emph{MTP\_f}}{}
\end{fulllineitems}

\index{MTP\_f() (in module MTP)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/MTP:MTP.MTP_f}\pysiglinewithargsret{\code{MTP.}\bfcode{MTP\_f}}{\emph{R\_eq}}{}
\end{fulllineitems}

\index{set\_MTP() (in module MTP)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/MTP:MTP.set_MTP}\pysiglinewithargsret{\code{MTP.}\bfcode{set\_MTP}}{\emph{K\_CP}, \emph{K\_RC}, \emph{m\_P}, \emph{f\_R}, \emph{f\_C}, \emph{f\_P}, \emph{MTP\_C}, \emph{MTP\_O}, \emph{MTP\_f}}{}
\end{fulllineitems}



\subsection{coarsegrainparams module}
\label{Model-Construction/coarsegrainparams:coarsegrainparams-module}\label{Model-Construction/coarsegrainparams::doc}\label{Model-Construction/coarsegrainparams:module-coarsegrainparams}\index{coarsegrainparams (module)}\index{alfa() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.alfa}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{alfa}}{\emph{m2}, \emph{alfa0}, \emph{pv}, \emph{pd}, \emph{D}, \emph{g}, \emph{f}}{}
\end{fulllineitems}

\index{b\_k (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.b_k}\pysigline{\code{coarsegrainparams.}\bfcode{b\_k}\strong{ = 8.617332400000001e-05}}
metabolic and biomechanic parameterization of the
search rate taking into consideration foraging strategies

\end{fulllineitems}

\index{f() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.f}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{f}}{\emph{k\_}, \emph{form}, \emph{a}, \emph{b}, \emph{c}}{}
\end{fulllineitems}

\index{g() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.g}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{g}}{\emph{k\_}, \emph{pv}, \emph{pd}, \emph{T1}, \emph{T2}, \emph{E1}, \emph{E2}, \emph{D}, \emph{v01}, \emph{v02}, \emph{fm}, \emph{thermy1}, \emph{thermy2}, \emph{k}}{}
\end{fulllineitems}

\index{set\_K() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.set_K}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{set\_K}}{\emph{k0}, \emph{mr}, \emph{w}, \emph{Ek}, \emph{Tr}, \emph{k}}{}
\end{fulllineitems}

\index{set\_alfa() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.set_alfa}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{set\_alfa}}{\emph{m2}, \emph{alfa0}, \emph{k\_}, \emph{pv}, \emph{pd}, \emph{T1}, \emph{T2}, \emph{E1}, \emph{E2}, \emph{D}, \emph{v01}, \emph{v02}, \emph{g}, \emph{alfa}, \emph{fm}, \emph{thermy1}, \emph{thermy2}, \emph{k}, \emph{a}, \emph{b}, \emph{c}, \emph{form}}{}
\end{fulllineitems}

\index{set\_alfa0() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.set_alfa0}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{set\_alfa0}}{\emph{d0}, \emph{D}}{}
\end{fulllineitems}

\index{set\_q1() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.set_q1}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{set\_q1}}{\emph{q10}, \emph{mc}, \emph{w}, \emph{Eq1}, \emph{Tc}, \emph{k}}{}
\end{fulllineitems}

\index{set\_q2() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.set_q2}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{set\_q2}}{\emph{q20}, \emph{mp}, \emph{w}, \emph{Eq2}, \emph{Tp}, \emph{k}}{}
\end{fulllineitems}

\index{set\_r() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.set_r}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{set\_r}}{\emph{r0}, \emph{mr}, \emph{w}, \emph{Er}, \emph{Tr}, \emph{k}}{}
\end{fulllineitems}

\index{set\_th() (in module coarsegrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/coarsegrainparams:coarsegrainparams.set_th}\pysiglinewithargsret{\code{coarsegrainparams.}\bfcode{set\_th}}{\emph{t\_h0}, \emph{m}, \emph{w}, \emph{E}, \emph{k}, \emph{T}}{}
\end{fulllineitems}



\subsection{fingrainparams module}
\label{Model-Construction/fingrainparams:fingrainparams-module}\label{Model-Construction/fingrainparams::doc}\label{Model-Construction/fingrainparams:module-fingrainparams}\index{fingrainparams (module)}\index{ConstructDynamicalFunctions() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.ConstructDynamicalFunctions}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{ConstructDynamicalFunctions}}{\emph{params}, \emph{par\_dict}, \emph{K\_RC}, \emph{K\_CP}, \emph{m\_P}, \emph{R}, \emph{C}, \emph{P}}{}
\end{fulllineitems}

\index{Jacobian() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.Jacobian}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{Jacobian}}{\emph{dR}, \emph{dC}, \emph{dP}, \emph{R}, \emph{C}, \emph{P}}{}
\end{fulllineitems}

\index{Jacobian2() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.Jacobian2}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{Jacobian2}}{\emph{dX}, \emph{dY}, \emph{X}, \emph{Y}}{}
\end{fulllineitems}

\index{Stability() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.Stability}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{Stability}}{\emph{params}, \emph{par\_dict}, \emph{eq\_dict}, \emph{K\_RC}, \emph{K\_CP}, \emph{m\_P}}{}
\end{fulllineitems}

\index{Trophic\_position() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.Trophic_position}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{Trophic\_position}}{\emph{params}, \emph{par\_dict}, \emph{eq\_dict}, \emph{m\_P}}{}
\end{fulllineitems}

\index{construct\_equilibrium() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.construct_equilibrium}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{construct\_equilibrium}}{\emph{params}, \emph{par\_dict}, \emph{K\_RC}, \emph{K\_CP}, \emph{m\_P}}{}
\end{fulllineitems}

\index{construct\_inv\_boundaries() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.construct_inv_boundaries}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{construct\_inv\_boundaries}}{\emph{params}, \emph{par\_dict}, \emph{eq\_dict}, \emph{K\_RC}, \emph{K\_CP}, \emph{m\_P}}{}
\end{fulllineitems}

\index{construct\_param\_dict() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.construct_param_dict}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{construct\_param\_dict}}{\emph{params}, \emph{K\_RC}, \emph{K\_CP}, \emph{m\_P}}{}
\end{fulllineitems}

\index{setJacobianDict() (in module fingrainparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/fingrainparams:fingrainparams.setJacobianDict}\pysiglinewithargsret{\code{fingrainparams.}\bfcode{setJacobianDict}}{\emph{DynamicsDict}, \emph{R}, \emph{C}, \emph{P}}{}
\end{fulllineitems}



\subsection{functions module}
\label{Model-Construction/functions:module-functions}\label{Model-Construction/functions:functions-module}\label{Model-Construction/functions::doc}\index{functions (module)}\index{func\_transform() (in module functions)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/functions:functions.func_transform}\pysiglinewithargsret{\code{functions.}\bfcode{func\_transform}}{\emph{params}, \emph{K\_CP}, \emph{K\_RC}, \emph{m\_P}, \emph{R}, \emph{C}, \emph{P}, \emph{sim=True}, \emph{bottom=False}}{}
\end{fulllineitems}

\index{setArgs() (in module functions)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/functions:functions.setArgs}\pysiglinewithargsret{\code{functions.}\bfcode{setArgs}}{\emph{args}}{}
\end{fulllineitems}



\subsection{interpopparams module}
\label{Model-Construction/interpopparams:interpopparams-module}\label{Model-Construction/interpopparams::doc}\label{Model-Construction/interpopparams:module-interpopparams}\index{interpopparams (module)}\index{alfa() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.alfa}\pysiglinewithargsret{\code{interpopparams.}\bfcode{alfa}}{\emph{m2}, \emph{alfa0}, \emph{pv}, \emph{pd}, \emph{D}, \emph{g}}{}
\end{fulllineitems}

\index{g() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.g}\pysiglinewithargsret{\code{interpopparams.}\bfcode{g}}{\emph{k\_}, \emph{pv}, \emph{pd}, \emph{T1}, \emph{T2}, \emph{E1}, \emph{E2}, \emph{D}, \emph{v01}, \emph{v02}, \emph{fm}, \emph{thermy1}, \emph{thermy2}, \emph{k}}{}
\end{fulllineitems}

\index{set\_K() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.set_K}\pysiglinewithargsret{\code{interpopparams.}\bfcode{set\_K}}{\emph{k0}, \emph{mr}, \emph{w}, \emph{Ek}, \emph{Tr}, \emph{k}}{}
\end{fulllineitems}

\index{set\_alfa() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.set_alfa}\pysiglinewithargsret{\code{interpopparams.}\bfcode{set\_alfa}}{\emph{m2}, \emph{alfa0}, \emph{k\_}, \emph{pv}, \emph{pd}, \emph{T1}, \emph{T2}, \emph{E1}, \emph{E2}, \emph{D}, \emph{v01}, \emph{v02}, \emph{g}, \emph{alfa}, \emph{fm}, \emph{thermy1}, \emph{thermy2}, \emph{k}}{}
\end{fulllineitems}

\index{set\_alfa0() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.set_alfa0}\pysiglinewithargsret{\code{interpopparams.}\bfcode{set\_alfa0}}{\emph{d0}, \emph{D}}{}
\end{fulllineitems}

\index{set\_q1() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.set_q1}\pysiglinewithargsret{\code{interpopparams.}\bfcode{set\_q1}}{\emph{q10}, \emph{mc}, \emph{w}, \emph{Eq1}, \emph{Tc}, \emph{k}}{}
\end{fulllineitems}

\index{set\_q2() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.set_q2}\pysiglinewithargsret{\code{interpopparams.}\bfcode{set\_q2}}{\emph{q20}, \emph{mp}, \emph{w}, \emph{Eq2}, \emph{Tp}, \emph{k}}{}
\end{fulllineitems}

\index{set\_r() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.set_r}\pysiglinewithargsret{\code{interpopparams.}\bfcode{set\_r}}{\emph{r0}, \emph{mr}, \emph{w}, \emph{Er}, \emph{Tr}, \emph{k}}{}
\end{fulllineitems}

\index{set\_th() (in module interpopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/interpopparams:interpopparams.set_th}\pysiglinewithargsret{\code{interpopparams.}\bfcode{set\_th}}{\emph{t\_h0}, \emph{m}, \emph{w}, \emph{E}, \emph{k}, \emph{T}}{}
\end{fulllineitems}



\subsection{inva\_fcl\_stab module}
\label{Model-Construction/inva_fcl_stab:inva-fcl-stab-module}\label{Model-Construction/inva_fcl_stab:module-inva_fcl_stab}\label{Model-Construction/inva_fcl_stab::doc}\index{inva\_fcl\_stab (module)}\index{setI\_C\_LV() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.setI_C_LV}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{setI\_C\_LV}}{\emph{C}, \emph{alfa3}, \emph{e3}, \emph{m\_P}}{}
\end{fulllineitems}

\index{setI\_C\_RM() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.setI_C_RM}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{setI\_C\_RM}}{\emph{C}, \emph{e3}, \emph{alfa3}, \emph{m\_P}, \emph{t\_hp}}{}
\end{fulllineitems}

\index{setI\_R\_LV() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.setI_R_LV}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{setI\_R\_LV}}{\emph{R}, \emph{alfa2}, \emph{e2}, \emph{m\_P}}{}
\end{fulllineitems}

\index{setI\_R\_RM() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.setI_R_RM}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{setI\_R\_RM}}{\emph{R}, \emph{e2}, \emph{alfa2}, \emph{m\_P}, \emph{t\_hp}}{}
\end{fulllineitems}

\index{setMPTEqRM() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.setMPTEqRM}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{setMPTEqRM}}{\emph{I\_R}, \emph{q\_2}}{}
\end{fulllineitems}

\index{setMTP() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.setMTP}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{setMTP}}{\emph{I\_R}, \emph{I\_C}}{}
\end{fulllineitems}

\index{set\_C\_eq\_s() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_C_eq_s}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_C\_eq\_s}}{\emph{m\_C}, \emph{r}, \emph{K}, \emph{q\_1}, \emph{a\_1}, \emph{e\_1}}{}
\end{fulllineitems}

\index{set\_D() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_D}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_D}}{\emph{K}, \emph{a\_1}, \emph{a\_2}, \emph{a\_3}, \emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{m\_C}, \emph{r}}{}
\end{fulllineitems}

\index{set\_I\_C\_s2() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_I_C_s2}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_I\_C\_s2}}{\emph{e\_1}, \emph{alfa\_1}, \emph{m\_C}, \emph{K}, \emph{q\_1}}{}
\end{fulllineitems}

\index{set\_I\_C\_s2RM() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_I_C_s2RM}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_I\_C\_s2RM}}{\emph{e\_1}, \emph{alfa\_1}, \emph{m\_C}, \emph{K}, \emph{q\_1}, \emph{hC\_0}, \emph{q1\_0}}{}
\end{fulllineitems}

\index{set\_I\_C\_s5() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_I_C_s5}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_I\_C\_s5}}{\emph{e\_1}, \emph{alfa\_1}, \emph{alfa\_3}, \emph{m\_C}, \emph{m\_P}, \emph{R}, \emph{P}, \emph{q\_1}}{}
\end{fulllineitems}

\index{set\_I\_C\_s5RM() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_I_C_s5RM}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_I\_C\_s5RM}}{\emph{e\_1}, \emph{e\_2}, \emph{alfa\_1}, \emph{alfa\_3}, \emph{m\_C}, \emph{m\_P}, \emph{R}, \emph{P}, \emph{q\_1}, \emph{t\_hc}, \emph{q1\_0}, \emph{q2\_0}, \emph{hP\_0}, \emph{hC\_0}}{}
\end{fulllineitems}

\index{set\_I\_P\_s3() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_I_P_s3}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_I\_P\_s3}}{\emph{e\_2}, \emph{alfa\_2}, \emph{m\_P}, \emph{K}, \emph{q\_2}}{}
\end{fulllineitems}

\index{set\_I\_P\_s3RM() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_I_P_s3RM}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_I\_P\_s3RM}}{\emph{e\_2}, \emph{alfa\_2}, \emph{m\_P}, \emph{K}, \emph{q\_2}, \emph{hP\_0}, \emph{q2\_0}}{}
\end{fulllineitems}

\index{set\_I\_P\_s4() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_I_P_s4}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_I\_P\_s4}}{\emph{e\_2}, \emph{e\_3}, \emph{alfa\_2}, \emph{alfa\_3}, \emph{m\_P}, \emph{q\_2}, \emph{R}, \emph{C}}{}
\end{fulllineitems}

\index{set\_I\_P\_s4RM() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_I_P_s4RM}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_I\_P\_s4RM}}{\emph{e\_2}, \emph{e\_3}, \emph{alfa\_2}, \emph{alfa\_3}, \emph{m\_P}, \emph{q\_2}, \emph{R}, \emph{C}, \emph{hP\_0}, \emph{q2\_0}}{}
\end{fulllineitems}

\index{set\_MTP\_C() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_MTP_C}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_MTP\_C}}{\emph{Req}, \emph{alfa2}, \emph{m\_P}, \emph{q\_2}, \emph{e2}}{}
\end{fulllineitems}

\index{set\_R\_C\_eq\_sRM() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_R_C_eq_sRM}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_R\_C\_eq\_sRM}}{\emph{m\_C}, \emph{r}, \emph{K}, \emph{q1}, \emph{q1\_0}, \emph{alfa\_1}, \emph{e\_1}, \emph{t\_hc}, \emph{hC\_0}}{}
\end{fulllineitems}

\index{set\_R\_eq\_s() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_R_eq_s}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_R\_eq\_s}}{\emph{m\_C}, \emph{q\_1}, \emph{a\_1}, \emph{e\_1}}{}
\end{fulllineitems}

\index{set\_a1() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_a1}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_a1}}{\emph{r}, \emph{Req}, \emph{K}}{}
\end{fulllineitems}

\index{set\_a2() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_a2}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_a2}}{\emph{e\_1}, \emph{e\_2}, \emph{e\_3}, \emph{a\_1}, \emph{a\_2}, \emph{a\_3}, \emph{m\_C}, \emph{m\_P}, \emph{Ceq}, \emph{Req}, \emph{Peq}}{}
\end{fulllineitems}

\index{set\_a3() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_a3}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_a3}}{\emph{D}, \emph{a\_3}, \emph{Ceq}, \emph{Req}, \emph{Peq}, \emph{K}, \emph{m\_C}, \emph{m\_P}}{}
\end{fulllineitems}

\index{set\_hdet2() (in module inva\_fcl\_stab)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/inva_fcl_stab:inva_fcl_stab.set_hdet2}\pysiglinewithargsret{\code{inva\_fcl\_stab.}\bfcode{set\_hdet2}}{\emph{a1}, \emph{a2}, \emph{a3}}{}
\end{fulllineitems}



\subsection{ipopparams module}
\label{Model-Construction/ipopparams:module-ipopparams}\label{Model-Construction/ipopparams:ipopparams-module}\label{Model-Construction/ipopparams::doc}\index{ipopparams (module)}\index{set\_K() (in module ipopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/ipopparams:ipopparams.set_K}\pysiglinewithargsret{\code{ipopparams.}\bfcode{set\_K}}{\emph{k0}, \emph{mr}, \emph{w}, \emph{Ek}, \emph{Tr}, \emph{k}}{}
\end{fulllineitems}

\index{set\_q1() (in module ipopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/ipopparams:ipopparams.set_q1}\pysiglinewithargsret{\code{ipopparams.}\bfcode{set\_q1}}{\emph{q10}, \emph{mc}, \emph{w}, \emph{Eq1}, \emph{Tc}, \emph{k}}{}
\end{fulllineitems}

\index{set\_q2() (in module ipopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/ipopparams:ipopparams.set_q2}\pysiglinewithargsret{\code{ipopparams.}\bfcode{set\_q2}}{\emph{q20}, \emph{mp}, \emph{w}, \emph{Eq2}, \emph{Tp}, \emph{k}}{}
\end{fulllineitems}

\index{set\_r() (in module ipopparams)}

\begin{fulllineitems}
\phantomsection\label{Model-Construction/ipopparams:ipopparams.set_r}\pysiglinewithargsret{\code{ipopparams.}\bfcode{set\_r}}{\emph{r0}, \emph{mr}, \emph{w}, \emph{Er}, \emph{Tr}, \emph{k}}{}
\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{AuxiliarClases}}, \pageref{Analisis/AuxiliarClases:module-AuxiliarClases}
\item {\texttt{Auxiliaryfunctions}}, \pageref{Analisis/Auxiliaryfunctions:module-Auxiliaryfunctions}
\indexspace
\bigletter{b}
\item {\texttt{Baseclass}}, \pageref{Analisis/Baseclass:module-Baseclass}
\item {\texttt{bounds}}, \pageref{Analisis/bounds:module-bounds}
\indexspace
\bigletter{c}
\item {\texttt{coarsegrainparams}}, \pageref{Model-Construction/coarsegrainparams:module-coarsegrainparams}
\indexspace
\bigletter{d}
\item {\texttt{Dynamics}}, \pageref{Model-Construction/Dynamics:module-Dynamics}
\indexspace
\bigletter{e}
\item {\texttt{Eq}}, \pageref{Model-Construction/Eq:module-Eq}
\item {\texttt{Equilibrium}}, \pageref{Model-Construction/Equilibrium:module-Equilibrium}
\item {\texttt{ExploreParams}}, \pageref{Analisis/ExploreParams:module-ExploreParams}
\item {\texttt{ExploreParamsProgram}}, \pageref{Analisis/ExploreParamsProgram:module-ExploreParamsProgram}
\indexspace
\bigletter{f}
\item {\texttt{fingrainparams}}, \pageref{Model-Construction/fingrainparams:module-fingrainparams}
\item {\texttt{functions}}, \pageref{Model-Construction/functions:module-functions}
\indexspace
\bigletter{i}
\item {\texttt{interpopparams}}, \pageref{Model-Construction/interpopparams:module-interpopparams}
\item {\texttt{inva\_fcl\_stab}}, \pageref{Model-Construction/inva_fcl_stab:module-inva_fcl_stab}
\item {\texttt{InvasionAnalysis}}, \pageref{Analisis/InvasionAnalysis:module-InvasionAnalysis}
\item {\texttt{ipopparams}}, \pageref{Model-Construction/ipopparams:module-ipopparams}
\indexspace
\bigletter{m}
\item {\texttt{MTP}}, \pageref{Model-Construction/MTP:module-MTP}
\indexspace
\bigletter{o}
\item {\texttt{OutputClasses}}, \pageref{Analisis/OutputClasses:module-OutputClasses}
\indexspace
\bigletter{r}
\item {\texttt{RMEquibrium}}, \pageref{Analisis/RMEquibrium:module-RMEquibrium}
\item {\texttt{roots}}, \pageref{Analisis/roots:module-roots}
\indexspace
\bigletter{s}
\item {\texttt{SimulationDynamics}}, \pageref{Analisis/SimulationDynamics:module-SimulationDynamics}
\indexspace
\bigletter{t}
\item {\texttt{TestProgram}}, \pageref{Analisis/TestProgram:module-TestProgram}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
